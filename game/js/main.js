!function(n){var e={};function t(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return n[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)t.d(r,i,function(e){return n[e]}.bind(null,i));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="file:///D:/nextHomeWork/game/dist/",t(t.s="./src/js/app.js")}({"./src/css/style.css":
/*!***************************!*\
  !*** ./src/css/style.css ***!
  \***************************/
/*! no static exports found */function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./src/css/style.css?")},"./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('__webpack_require__(/*! ../css/style.css */ "./src/css/style.css");\r\n// 元素\r\nlet container = document.getElementById(\'game\');\r\nlet Continuer = container.querySelector(".game-next-level");\r\nlet overer = document.querySelector(".score");\r\nlet canvas = document.querySelector("#canvas");\r\nlet context = canvas.getContext("2d");\r\n// 兼容定义 requestAnimFrame\r\nwindow.requestAnimFrame =\r\n    window.requestAnimationFrame ||\r\n    window.webkitRequestAnimationFrame ||\r\n    window.mozRequestAnimationFrame ||\r\n    window.oRequestAnimationFrame ||\r\n    window.msRequestAnimationFrame ||\r\n    function(callback) {\r\n        window.setTimeout(callback, 1000 / 30);\r\n    };\r\n\r\n\r\n/**\r\n * 游戏配置设置要求 （canvas.height-planeSize.height-2*canvasPadding）可以被enemySize 整除\r\n */\r\n/**\r\n * 整个游戏对象\r\n */\r\nvar GAME = {\r\n    level:1,\r\n    shootSpeed:100, //飞机射击频率\r\n    moveSpeed:15, //飞机移动频率\r\n    totalLevel: 6, // 总共6关\r\n    numPerline: 6 , // 游戏默认每行多少个怪兽\r\n    canvasPadding: 30, // 默认画布的间隔\r\n    bulletSize:10, // 默认子弹长度\r\n    bulletSpeed: 10, // 默认子弹的移动速度\r\n    bulletWidth:1,//默认子弹宽度\r\n    enemySpeed: 2, // 默认敌人移动距离\r\n    enemySize: 50, // 默认敌人的尺寸\r\n    enemyGap: 20,  // 默认敌人之间的间距\r\n    enemyIcon: \'./img/enemy.png\', // 怪兽的图像\r\n    enemyBoomIcon: \'./img/boom.png\', // 怪兽死亡的图像\r\n    enemyDirection: \'right\', // 默认敌人\b一开始往右移动\r\n    planeSpeed: 5, // 默认飞机每一步移动的距离\r\n    planeSize: {\r\n        width: 60,\r\n        height: 100\r\n    }, // 默认飞机的尺寸,\r\n    planeIcon: \'./img/plane.png\',\r\n    keyStatus:{},\r\n  /**\r\n   * 初始化函数,这个函数只执行一次\r\n   * @param  {object} opts \r\n   * @return {[type]}      [description]\r\n   */\r\n  init: function(opts) {\r\n    this.status = \'start\';\r\n    this.bindEvent();\r\n  },\r\n  bindEvent: function() {\r\n    let self = this;\r\n    let playBtn = document.querySelector(\'.js-play\');\r\n    // 开始游戏按钮绑定\r\n    playBtn.onclick = function() {\r\n      self.play();\r\n    };\r\n    let ContinueBtn = document.querySelector(".js-next");\r\n      ContinueBtn.onclick = function () {\r\n          self.play();\r\n      };\r\n    let rePlayBtns = document.querySelectorAll(".js-replay");\r\n      rePlayBtns.forEach(x=>x.onclick=()=>self.reStart());\r\n  },\r\n  /**\r\n   * 更新游戏状态，分别有以下几种状态：\r\n   * start  游戏前\r\n   * playing 游戏中\r\n   * failed 游戏失败\r\n   * success 游戏成功\r\n   * all-success 游戏通过\r\n   * stop 游戏暂停（可选）\r\n   */\r\n  setStatus: function(status) {\r\n      this.status = status;\r\n    container.setAttribute("data-status", status);\r\n  },\r\n  setLevel:function () {\r\n        this.level++;\r\n        Continuer.innerHTML = `下一关等级：${this.level}`;\r\n      GAME.totalCode.code = 0;\r\n  },\r\n  setOver:function () {\r\n      GAME.totalCode.allCode += GAME.totalCode.code;\r\n      overer.innerHTML = GAME.totalCode.allCode;\r\n      GAME.totalCode.code = 0;\r\n  },\r\n  play: function() {\r\n      GAME.setStatus(\'playing\');\r\n      GAME.changeConfig();\r\n      GAME.start();\r\n  },\r\n  reStart: function () {\r\n      // console.log("1");\r\n      GAME.totalCode.allCode = 0;\r\n      GAME.totalCode.code = 0;\r\n      this.setStatus("start");\r\n      GAME.level=1;\r\n      context.clearRect(0,0,canvas.width,GAME.canvasPadding);\r\n  },\r\n  changeConfig:function () {\r\n      GAME.keyStatus={};\r\n      GAME.numPerline = 5 + GAME.level; // 游戏默认每行多少个怪兽\r\n      GAME.enemySpeed = 1 + GAME.level; // 默认敌人移动距离\r\n      GAME.enemySize = 53-GAME.level*5; // 默认敌人的尺寸\r\n      GAME.enemyGap =  17+2*GAME.level;  // 默认敌人之间的间距\r\n  }\r\n  ,\r\n  start:function(){\r\n      this.totalCode.draw();\r\n\r\n      this.enemy.init();\r\n      // console.log(this.enemy.x);\r\n      this.plane.init();\r\n      // console.log(GAME.enemy, 1);\r\n      this.enemy.animate();\r\n      this.listener();\r\n      this.collisionDetection();\r\n  },\r\n    totalCode:{\r\n      allCode:0,\r\n      code:0,\r\n      x:20,\r\n      y:20,\r\n      font:"18px 宋体",\r\n      draw:()=>{\r\n          context.clearRect(0,0,canvas.width,GAME.canvasPadding);\r\n          context.font=GAME.totalCode.font;\r\n          context.fillStyle="white";\r\n          context.textAlign = \'left\';\r\n          // context.textBaselevel = "top";\r\n          context.fillText(`分数：${GAME.totalCode.code}`,GAME.totalCode.x,GAME.totalCode.y);\r\n      }}\r\n    ,\r\n   listener:()=>{\r\n      //检测子弹和敌人的碰撞事件\r\n       // 全局监听键盘操作的 keydown 移动事件\r\n       document.addEventListener("keyup",function (e) {\r\n           if(GAME.status==="playing"){\r\n               // 获取被按下的键值 (兼容写法)\r\n               let key = e.keyCode || e.which || e.charCode;\r\n               switch (key) {\r\n                   // 点击左方向键\r\n                   case 37: {\r\n                       GAME.keyStatus[37]=false;\r\n                       break;\r\n                   }\r\n                   // 点击上方向键或空格键\r\n                   case 32:\r\n                   case 38: {\r\n                       GAME.keyStatus[key]=false;\r\n                       break;\r\n                   }\r\n                  // 点击右方向键\r\n                   case 39: {\r\n                       GAME.keyStatus[39]=false;\r\n                       break;\r\n                   }\r\n                   default:\r\n                       break;\r\n               }\r\n           }\r\n       });\r\n       // 全局监听键盘操作的 keydown 射击事件\r\n       document.addEventListener("keydown",function (e) {\r\n           if(GAME.status==="playing"){\r\n               // 获取被按下的键值 (兼容写法)\r\n               let key = e.keyCode || e.which || e.charCode;\r\n               switch (key) {\r\n                   // 点击左方向键\r\n                   case 37: {\r\n                      GAME.keyStatus[37]=true;\r\n                       break;\r\n                   }\r\n                   // 点击上方向键或空格键\r\n                   case 32:\r\n                   case 38: {\r\n                       GAME.keyStatus[key]=true;\r\n                       // console.log(GAME.bullets);\r\n                       break;\r\n                   }\r\n                   // 点击右方向键\r\n                   case 39: {\r\n                       GAME.keyStatus[39]=true;\r\n                       break;\r\n                   }\r\n                   default:\r\n                       break;\r\n               }\r\n           }\r\n       });\r\n       let listenerId1,listenerId2;\r\n       function move() {\r\n           clearInterval(listenerId1);\r\n           if(GAME.status!=="playing"){\r\n               return;\r\n           };\r\n           if(GAME.keyStatus[37]){\r\n               if ((GAME.plane.x - GAME.planeSpeed < GAME.canvasPadding)) {\r\n                   GAME.plane.x = GAME.canvasPadding;\r\n               } else {\r\n                   GAME.plane.x -= GAME.planeSpeed;\r\n               };\r\n               GAME.plane.draw();\r\n           };\r\n           if(GAME.keyStatus[39]){\r\n               if ((GAME.plane.x + GAME.planeSpeed > canvas.width - GAME.canvasPadding - GAME.planeSize.width)) {\r\n                   GAME.plane.x = canvas.width - GAME.canvasPadding - GAME.planeSize.width;\r\n               } else {\r\n                   GAME.plane.x += GAME.planeSpeed;\r\n               };\r\n               GAME.plane.draw();\r\n           };\r\n           listenerId1 = window.setInterval(move, GAME.moveSpeed);\r\n       }\r\n       function  shoot() {\r\n           clearInterval(listenerId2);\r\n           if(GAME.status!=="playing"){\r\n               return;\r\n           };\r\n           if(GAME.keyStatus[32]||GAME.keyStatus[38]){\r\n               const spt = Date.parse(new Date()) + parseInt(Math.random() * 100);\r\n               const bullet = new Bullet(spt);\r\n               bullet.init().bulletDraw().animate2();\r\n               GAME.bullets[spt] = bullet;\r\n           };\r\n           listenerId2 = window.setInterval(shoot, GAME.shootSpeed);\r\n       }\r\n       move();\r\n       shoot();\r\n   },\r\n    collisionDetection:()=>{\r\n        GAME.requestId && cancelAnimationFrame(GAME.requestId);\r\n      if(GAME.status!=="playing"){return};\r\n      for(let i in GAME.enemy.deathList){\r\n          for(let j =0;j<=GAME.enemy.deathList[i].length-1;j++){\r\n              if(GAME.enemy.deathList[i][j]==="live"){\r\n                  for(let y in GAME.bullets){\r\n                      // 判断四边是否都没有空隙\r\n                      if (!(GAME.enemy.x[i][j] + GAME.enemySize < GAME.bullets[y].x) &&\r\n                          !((GAME.bullets[y].x-GAME.bulletWidth/2) + GAME.bulletWidth*1.2 < GAME.enemy.x[i][j]) &&\r\n                          !(GAME.enemy.y[i] + GAME.enemySize < GAME.bullets[y].y) &&\r\n                          !(GAME.bullets[y].y + GAME.bulletSize < GAME.enemy.y[i])) {\r\n                          GAME.totalCode.code++;\r\n                          GAME.totalCode.draw();\r\n                          // function Boom(i) {\r\n                          //     let num = 0;\r\n                          //     (function death(num,i) {\r\n                          //         cancelAnimationFrame(requestId);\r\n                          //         num++;\r\n                          //         console.log(num, i);\r\n                          //         if(num===3){\r\n                          //             return  GAME.enemy.deathList[i]="death";\r\n                          //         }\r\n                          //         requestId = requestAnimFrame(death);\r\n                          //     })(num,i);\r\n                          // }\r\n                          // Boom(i);\r\n                          (function (i,j) {\r\n                              // 物体碰撞了\r\n                              GAME.enemy.deathList[i][j]="boom";\r\n                              const requestId = window.setTimeout(function(){\r\n                                  // console.log("hahaha",i);\r\n                                  GAME.enemy.deathList[i][j]="death";\r\n                                  clearTimeout(requestId)\r\n                              }, 100);\r\n                          })(i,j);\r\n                          GAME.bullets[y].death=true;\r\n                          break;\r\n                      }\r\n                  }\r\n              };\r\n          }\r\n\r\n      };\r\n      let allEnemys = [];\r\n      for(let k in GAME.enemy.deathList){\r\n          allEnemys=allEnemys.concat(GAME.enemy.deathList[k]);\r\n      };\r\n      if(allEnemys.indexOf("live")===-1){\r\n          GAME.totalCode.allCode += GAME.totalCode.code;\r\n          GAME.totalCode.code = 0;\r\n          // console.log(GAME.level, GAME.totalLevel);\r\n          cancelAnimationFrame(GAME.enemy.requestId);\r\n          // 清除画布\r\n          context.clearRect(0, 0, canvas.width, canvas.height-GAME.canvasPadding);\r\n          if(GAME.level<GAME.totalLevel){\r\n              GAME.setLevel();\r\n              GAME.setStatus("success");\r\n          };\r\n          if(GAME.level==GAME.totalLevel){\r\n              GAME.reStart();\r\n              GAME.setStatus("all-success");\r\n          };\r\n          return;\r\n      };\r\n        GAME.requestId = requestAnimFrame(GAME.collisionDetection);\r\n    },\r\n    enemy:{\r\n      deathList:{},\r\n      x:{},\r\n      y:[],\r\n      init:function () {\r\n          this.deathList={};\r\n          this.x={};\r\n          this.y=[];\r\n          this.lastLiveline=GAME.level-1;\r\n          for(let i=0;i<=GAME.level-1;i++ ){\r\n              this.x[i]=[],this.deathList[i]=[];\r\n              this.y[i]=GAME.canvasPadding+i*GAME.enemySize;\r\n              for(let j=0;j<=GAME.numPerline-1;j++){\r\n                  this.x[i][j] = GAME.canvasPadding+j*(GAME.canvasPadding+GAME.enemyGap);\r\n                  this.deathList[i][j] = "live";\r\n              };\r\n          };\r\n          // console.log(this,this.lastLiveline,GAME.numPerline,GAME.level,"0");\r\n          this.draw();\r\n  },\r\n      draw:function () {\r\n          let image;\r\n          // console.log(GAME.enemy,"1");\r\n          for(let i  in this.deathList){\r\n              for(let j=0;j<=this.deathList[i].length-1;j++){\r\n                  if(this.deathList[i][j]==="death"){\r\n                      continue;\r\n                  }else{\r\n                     image = this.deathList[i][j]==="boom"? GAME.enemyBoomIcon:GAME.enemyIcon;\r\n                  };\r\n                  let enemyImage = new Image();\r\n                  enemyImage.src = image;\r\n                  enemyImage.onload = (function (i,j) {\r\n                      // console.log(GAME.enemy,i,j,2);\r\n                      context.drawImage(enemyImage,GAME.enemy.x[i][j],GAME.enemy.y[i],GAME.enemySize,GAME.enemySize);\r\n                  })(i,j);\r\n              }\r\n\r\n          };\r\n      },\r\n      move:function () {\r\n          // console.log(this);\r\n          // console.log(GAME.enemySpeed,GAME.enemy);\r\n          if(GAME.enemyDirection==="right"){\r\n              let maxRightLives=[];\r\n           for(let u in this.deathList){\r\n               for(let o = this.deathList[u].length-1;o>=0;o--){\r\n                   if(this.deathList[u][o]==="live"){\r\n                       maxRightLives.push(o);\r\n                       break;\r\n                   }\r\n               };\r\n           };\r\n              let maxRightLive=Math.max(...maxRightLives);\r\n               // console.log(maxRightLive);\r\n              // console.log(this,maxRightLive,maxRightLives);\r\n              // console.log(this.deathList[u],this.x[u], (canvas.width - GAME.canvasPadding - GAME.enemySize));\r\n               if(this.x[0][maxRightLive]<(canvas.width-GAME.canvasPadding-GAME.enemySize)){\r\n                   for(let i in this.x){\r\n                       for(let p=0;p<this.x[i].length;p++){\r\n                           this.x[i][p]+=GAME.enemySpeed;\r\n                       };\r\n                   }\r\n               }else{\r\n                   GAME.enemyDirection="left";\r\n                   for(let y = this.y.length-1;y>=0;y--){\r\n                       // console.log(GAME.enemy.deathList, y);\r\n                      if(GAME.enemy.deathList[y].indexOf("live")!=-1){\r\n                          this.lastLiveline = y;\r\n                          if((this.y[y]+GAME.enemySize*2)>(canvas.height-GAME.canvasPadding-GAME.planeSize.height)){\r\n                              cancelAnimationFrame(GAME.enemy.requestId);\r\n                              // 清除画布\r\n                              context.clearRect(0, GAME.canvasPadding, canvas.width, canvas.height-GAME.canvasPadding);\r\n                              GAME.setOver();\r\n                              GAME.setStatus("failed");\r\n                              return 1;\r\n                          }else{\r\n                             for(let e =0;e<this.y.length;e++){\r\n                               this.y[e]+=GAME.enemySize\r\n                             };\r\n                          }\r\n                          break;\r\n                      }\r\n                   }\r\n               };\r\n\r\n       }else{\r\n              let maxLeftLives=[];\r\n              for(let u in this.deathList){\r\n                  for(let o = 0;o<=this.deathList[u].length-1;o++){\r\n                      if(this.deathList[u][o]==="live"){\r\n                          maxLeftLives.push(o);\r\n                          break;\r\n                      }\r\n                  };\r\n              };\r\n                  let maxLeftLive=Math.min(...maxLeftLives);\r\n                  // console.log(this.deathList[u],this.x[u], (canvas.width - GAME.canvasPadding - GAME.enemySize));\r\n                  if(this.x[0][maxLeftLive]>GAME.canvasPadding){\r\n                      for(let i in this.x){\r\n                          for(let p=0;p<this.x[i].length;p++){\r\n                              this.x[i][p]-=GAME.enemySpeed;\r\n                          };\r\n                      }\r\n                  }else{\r\n                      GAME.enemyDirection="right";\r\n                      for(let y = this.y.length-1;y>=0;y--){\r\n                          // console.log(GAME.enemy.deathList, y);\r\n                          if(GAME.enemy.deathList[y].indexOf("live")!=-1){\r\n                              this.lastLiveline = y;\r\n                              if((this.y[y]+GAME.enemySize*2)>(canvas.height-GAME.canvasPadding-GAME.planeSize.height)){\r\n                                  cancelAnimationFrame(GAME.enemy.requestId);\r\n                                  // 清除画布\r\n                                  context.clearRect(0, GAME.canvasPadding, canvas.width, canvas.height-GAME.canvasPadding);\r\n                                  GAME.setOver();\r\n                                  GAME.setStatus("failed");\r\n                                  return 1;\r\n                              }else{\r\n                                  for(let e =0;e<this.y.length;e++){\r\n                                      this.y[e]+=GAME.enemySize\r\n                                  };\r\n                              }\r\n                              break;\r\n                          }\r\n                      }\r\n                  };\r\n\r\n       }\r\n      },\r\n        animate:function() {\r\n            GAME.enemy.requestId && cancelAnimationFrame(GAME.enemy.requestId);\r\n            // 更新位置\r\n            // console.log(GAME.enemy,2);\r\n            let flag = GAME.enemy.move();\r\n            if(flag===1||GAME.status!=="playing"){return};\r\n            // 清除画布\r\n            context.clearRect(0, GAME.canvasPadding, canvas.width, GAME.enemy.y[GAME.enemy.lastLiveline]+GAME.enemySize-GAME.canvasPadding);\r\n            // 重绘\r\n            GAME.enemy.draw();\r\n            // 使用requestAnimationFrame实现动画循环\r\n            // console.log("根本停不下来");\r\n            GAME.enemy.requestId = requestAnimFrame(GAME.enemy.animate);\r\n        },\r\n  },\r\n  plane: {\r\n      x: 0,\r\n      y: 0,\r\n      init: function () {\r\n          this.x = canvas.width / 2 - GAME.planeSize.width / 2;\r\n          this.y = canvas.height - GAME.planeSize.height - GAME.canvasPadding;\r\n          GAME.plane.draw();\r\n      },\r\n      draw:function () {\r\n          let planeImage = new Image();\r\n          planeImage.src = GAME.planeIcon;\r\n          planeImage.onload = () =>{\r\n              //清理飞机活动区域画布\r\n              context.clearRect(0,canvas.height-GAME.canvasPadding-GAME.planeSize.height,canvas.width,GAME.planeSize.height);\r\n              context.drawImage(planeImage, this.x, this.y, GAME.planeSize.width, GAME.planeSize.height)\r\n          };\r\n      },\r\n      // moveAndShootCallBack:function (callBack) {\r\n      //     window.setTimeout(callBack, GAME.moveAndShootSpeed);\r\n      // }\r\n  },\r\n    bullets:{},\r\n};\r\nfunction Bullet(time) {\r\n    this.death=false;\r\n    this.time=time;\r\n    this.x=0;\r\n    this.y=0;\r\n    this.init=()=> {\r\n        this.x=GAME.plane.x+(GAME.planeSize.width/2);\r\n        this.y=GAME.plane.y;\r\n        return this;\r\n    };\r\n    this.bulletDraw=()=>{\r\n        context.beginPath();\r\n        context.lineWidth = GAME.bulletWidth;\r\n        context.strokeStyle="white";\r\n        context.moveTo(this.x,this.y-GAME.bulletSize);\r\n        context.lineTo(this.x,this.y);\r\n        context.closePath();\r\n        context.stroke();\r\n        return this;\r\n    };\r\n    this.move=()=>{\r\n        if(this.y-GAME.bulletSpeed>0){\r\n            this.y-=GAME.bulletSpeed;\r\n        }else{\r\n            this.death=true;\r\n        }\r\n    };\r\n    this.animate2=()=>{\r\n        // 更新子弹位置\r\n\r\n        this.move();\r\n        // console.log(this.requestId);\r\n        this.requestId && cancelAnimationFrame(this.requestId);\r\n        // console.log(this.x - GAME.bulletWidth / 2, this.y, GAME.bulletWidth, GAME.bulletSize);\r\n        // 清除画布\r\n        context.clearRect(this.x-GAME.bulletWidth/2,this.y,GAME.bulletWidth*1.2,GAME.bulletSize*1.1);\r\n        //画子弹\r\n        !this.death && this.bulletDraw();\r\n        if(this.death||GAME.status!=="playing"){\r\n            context.clearRect(this.x-GAME.bulletWidth/2,this.y-GAME.bulletSize,GAME.bulletWidth*1.2,GAME.bulletSize*1.05);\r\n            this.clearNode(this);\r\n            return;\r\n        }\r\n        // 使用requestAnimationFrame实现动画循环\r\n        this.requestId = requestAnimFrame(this.animate2);\r\n    };\r\n    this.clearNode=(that)=>{\r\n        for(let x in GAME.bullets){\r\n            // console.log(that.time, x, that.time == x);\r\n            that.time==x && delete GAME.bullets[x];\r\n        };\r\n    };\r\n}\r\n\r\n\r\n// 初始化\r\nGAME.init();\r\n\r\n\n\n//# sourceURL=webpack:///./src/js/app.js?')}});